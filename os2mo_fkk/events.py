# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
from datetime import timedelta
from enum import StrEnum
from enum import auto
from uuid import UUID

import structlog
from fastramqpi.ramqp import Router
from fastramqpi.ramqp.depends import RateLimit
from fastramqpi.ramqp.mo import MORouter
from fastramqpi.ramqp.mo import PayloadUUID
from more_itertools import one
from more_itertools import only

from os2mo_fkk import depends
from os2mo_fkk.autogenerated_graphql_client import GraphQLClient
from os2mo_fkk.klassifikation.api import FKKAPI
from os2mo_fkk.models import class_validity_to_create_input
from os2mo_fkk.models import class_validity_to_update_input
from os2mo_fkk.models import fkk_klasse_to_class_validities
from os2mo_fkk.models import mo_class_read_to_class_validities

logger = structlog.stdlib.get_logger()

mo_router = MORouter()
fkk_router = Router()


@mo_router.register("class")
async def mo_handler(
    uuid: PayloadUUID, mo: depends.GraphQLClient, fkk: depends.FKKAPI, _: RateLimit
) -> None:
    await sync(uuid, mo, fkk)


@fkk_router.register("change")
async def fkk_handler(
    uuid: PayloadUUID, mo: depends.GraphQLClient, fkk: depends.FKKAPI, _: RateLimit
) -> None:
    await sync(uuid, mo, fkk)


class SyncStatus(StrEnum):
    CREATE_OR_UPDATE = auto()
    DELETE = auto()
    UP_TO_DATE = auto()
    WONT_DELETE = auto()


async def sync(uuid: UUID, mo: GraphQLClient, fkk: FKKAPI) -> SyncStatus:
    """Synchronise FKK Klasse to MO."""
    log = logger.bind(uuid=uuid)
    log.info("Synchronising class")

    # Read current state from both FKK and OS2mo
    fkk_klasse = await fkk.read(uuid)
    mo_classes = await mo.get_class(uuid)
    mo_class = only(mo_classes.objects)
    kle_number_facet = one((await mo.get_facet("kle_number")).objects).uuid

    # Convert to intermediate ClassValidity objects to allow comparison
    actual = set()
    if mo_class is not None:
        actual = set(mo_class_read_to_class_validities(mo_class))

    desired = set()
    if fkk_klasse is not None:
        desired = set(
            fkk_klasse_to_class_validities(fkk_klasse, facet=kle_number_facet)
        )

    if desired:
        # TODO(#61751): MO does not support datetimes with a time. Truncate
        # time from the validity to avoid infinite synchronisation loops.
        desired = {d.with_validity_as_dates() for d in desired}

        # TODO(#61435): MO does not support objects with a validity less than a day
        single_day_desired = {
            d
            for d in desired
            if (d.validity.end - d.validity.start) <= timedelta(days=1)
        }
        if single_day_desired:
            logger.warning(
                "Ignoring desired single-day class validities",
                ignored=single_day_desired,
            )
            desired -= single_day_desired

    log.info("Synchronise", actual=actual, desired=desired)

    # The actual and desired state can match either if the class is equal in both
    # systems *or* if it is missing (None) in both.
    if actual == desired:
        log.info("Actual state matches desired state: nothing to do")
        return SyncStatus.UP_TO_DATE

    # The FKK klasse does not exist
    if not desired:
        # MO class must exist or the states would be equal
        assert mo_class is not None
        # The UUID we are handling could be missing from FKK because it was
        # deleted, but it could also be a class from MO that has nothing to do
        # with FKK. We have no way to know since there is nothing in FKK
        # (anymore), so we err on the side of caution and abort if the MO class
        # is not under the kle_number facet. This allows us to clean-up deleted
        # FKK classes in all cases except if someone manually moves it to a
        # different facet between events after it was deleted from FKK.
        mo_class_facets = {validity.facet_uuid for validity in mo_class.validities}
        if mo_class_facets != {kle_number_facet}:
            log.info("MO class is not KLE: won't delete")
            return SyncStatus.WONT_DELETE
        log.info("Deleting class from MO")
        await mo.delete_class(uuid)
        return SyncStatus.DELETE

    # The FKK klasse exists, and we have a set of desired intermediate
    # ClassValidity states we need to synchronise to MO. Each validity can be
    # added to MO using either a GraphQL `class_create` or `class_update`.
    if not actual:
        # If the class does not already exist in MO, we select a random
        # validity and `class_create` using it.
        log.info("Creating new class in MO")
        some_validity = desired.pop()
        create_input = class_validity_to_create_input(some_validity)
        await mo.create_class(create_input)
    else:
        # Otherwise, we truncate all the class's existing validities using
        # `class_terminate`.
        log.info("Truncating existing class validities in MO")
        await mo.truncate_class(uuid)

    # In either case, we now have a MO class to which we can `class_update` the
    # remaining desired validities.
    log.info("Updating class validities in MO")
    for validity in desired:
        update_input = class_validity_to_update_input(validity)
        await mo.update_class(update_input)

    return SyncStatus.CREATE_OR_UPDATE
