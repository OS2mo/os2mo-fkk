# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
import itertools
from datetime import datetime
from datetime import time
from datetime import timedelta
from typing import Iterator
from typing import Self
from uuid import UUID

import structlog
from more_itertools import one
from more_itertools import only

from os2mo_fkk.autogenerated_graphql_client import (
    ClassCreateInput as MOClassCreateInput,
)
from os2mo_fkk.autogenerated_graphql_client import (
    ClassUpdateInput as MOClassUpdateInput,
)
from os2mo_fkk.autogenerated_graphql_client import (
    GetClassClassesObjects as MOGetClassClassesObjects,
)
from os2mo_fkk.autogenerated_graphql_client.get_class import (
    GetClassClassesObjectsValiditiesValidity,
)
from os2mo_fkk.autogenerated_graphql_client.input_types import ValidityInput
from os2mo_fkk.klassifikation.models import HasVirking as HasFKKVirkning
from os2mo_fkk.klassifikation.models import Klasse as FKKKlasse
from os2mo_fkk.util import NEGATIVE_INFINITY
from os2mo_fkk.util import POSITIVE_INFINITY
from os2mo_fkk.util import StrictBaseModel

logger = structlog.stdlib.get_logger()


class Validity(StrictBaseModel):
    start: datetime
    end: datetime

    @classmethod
    def from_mo(cls, mo: GetClassClassesObjectsValiditiesValidity) -> Self:
        """MO uses None for infinity."""
        return cls(
            start=mo.from_ or NEGATIVE_INFINITY,
            end=mo.to or POSITIVE_INFINITY,
        )

    def to_mo(self) -> ValidityInput:
        """MO uses None for infinity."""
        return ValidityInput(
            from_=None if self.start is NEGATIVE_INFINITY else self.start,
            to=None if self.end is POSITIVE_INFINITY else self.end,
        )


class ClassValidity(StrictBaseModel):
    """Intermediate, comparable Class model.

    Both FKK Klasser and MO GraphQL Classes will be converted to this model for
    comparison. Used to determine actual vs desired state in OS2mo. See
    fkk_klasse_to_class_validities() for an explanation of the conversion logic.
    """

    facet: UUID
    validity: Validity
    uuid: UUID
    user_key: str
    name: str
    parent: UUID | None


def fkk_klasse_to_class_validities(
    klasse: FKKKlasse, facet: UUID
) -> Iterator[ClassValidity]:
    """Splits FKK Klasse object into Class validities.

    FKK Klasse objects are temporal, meaning that a single object contains all of its
    temporal changes. MO objects, on the other hand, model temporal changes by multiple
    validity "states" for each object. The values for each state are static; temporal
    changes are expressed through multiple states, none of which overlap.

    To convert from an FKK Klasse to a MO Class, we must therefore "split" the Klasse
    at each point in time where there is a change in any of its attributes, and
    construct a MO Class "state" for that time period.
    """
    # The following logic is based on a similar function in OS2mo, which does the same
    # for LoRa objects (which, like FKK, expose objects using the OIO-standard):
    # https://git.magenta.dk/rammearkitektur/os2mo/-/blob/f7317cec9a128d66b61e16c0315b039c35ac9e32/backend/mora/lora.py#L807-881

    # Collect all start and end timestamps in the FKK Klasse
    validity_objects = itertools.chain(
        klasse.attribut_egenskab,
        klasse.tilstand_publiceret,
        klasse.relation_overordnet,
    )
    timestamps = set()
    for obj in validity_objects:
        timestamps.add(obj.virkning.fra)
        timestamps.add(obj.virkning.til)

    def filter_virkning(
        objects: list[HasFKKVirkning], start: datetime, end: datetime
    ) -> Iterator[HasFKKVirkning]:
        return (
            obj
            for obj in objects
            if obj.virkning.fra < end and obj.virkning.til > start
        )

    # Construct intermediate Class validity state for each timestamp pair
    for start, end in itertools.pairwise(sorted(timestamps)):
        # The published state of an FKK Klasse designates whether the object is
        # considered "valid" according to the business logic in the interval. There is
        # no guarantee that the constructed MO Class validity will be consistent (i.e.
        # static in all values) during unpublished time periods, so we skip
        # constructing MO Class validities for these periods.
        published = one(filter_virkning(klasse.tilstand_publiceret, start, end))
        if not published.er_publiceret:
            continue

        attribute = one(filter_virkning(klasse.attribut_egenskab, start, end))
        parent = only(filter_virkning(klasse.relation_overordnet, start, end))

        yield ClassValidity(
            facet=facet,
            validity=Validity(
                start=start,
                end=end,
            ),
            uuid=klasse.uuid,
            user_key=attribute.brugervendtnoegle,
            name=attribute.titel,
            parent=parent.uuid if parent is not None else None,
        )


def mo_class_read_to_class_validities(
    mo_class: MOGetClassClassesObjects,
) -> Iterator[ClassValidity]:
    """Convert MO GraphQL Class object to ClassValidity intermediate objects."""
    for validity in mo_class.validities:
        # TODO (#61435): MOs GraphQL subtracts one day from the validity end dates when
        # reading, compared to what was written. This breaks the comparison and leads
        # to infinite synchronisation loops.
        validity_end = validity.validity.to
        if validity_end is not None:
            assert validity_end.time() == time.min
            validity_end += timedelta(days=1)

        yield ClassValidity(
            facet=validity.facet_uuid,
            validity=Validity.from_mo(validity.validity),
            uuid=validity.uuid,
            user_key=validity.user_key,
            name=validity.name,
            parent=validity.parent_uuid,
        )


def class_validity_to_create_input(class_validity: ClassValidity) -> MOClassCreateInput:
    """Convert ClassValidity intermediate object to MO GraphQL class_create input."""
    return MOClassCreateInput(
        facet_uuid=class_validity.facet,
        validity=class_validity.validity.to_mo(),
        uuid=class_validity.uuid,
        user_key=class_validity.user_key,
        name=class_validity.name,
        parent_uuid=class_validity.parent,
    )


def class_validity_to_update_input(class_validity: ClassValidity) -> MOClassUpdateInput:
    """Convert ClassValidity intermediate object to MO GraphQL class_update input."""
    return MOClassUpdateInput(
        facet_uuid=class_validity.facet,
        validity=class_validity.validity.to_mo(),
        uuid=class_validity.uuid,
        user_key=class_validity.user_key,
        name=class_validity.name,
        parent_uuid=class_validity.parent,
    )
